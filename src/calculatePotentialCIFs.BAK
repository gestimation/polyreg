#include <Rcpp.h>
#include <nlopt.hpp>
using namespace Rcpp;

// CIFsData struct to hold parameters
struct CIFsData {
  double alpha_tmp_1;
  std::vector<double> beta_tmp_1;
  double alpha_tmp_2;
  std::vector<double> beta_tmp_2;
  std::string effect1;
  std::string effect2;
  double prob_bound;
};

// Equivalent to estimating_equation_CIFs() objective function
double CppObjectiveFunction(const std::vector<double>& log_p,
                            double alpha_tmp_1,
                            const std::vector<double>& beta_tmp_1,
                            double alpha_tmp_2,
                            const std::vector<double>& beta_tmp_2,
                            const std::string& effect1,
                            const std::string& effect2,
                            double prob_bound) {
  auto clampLogP = [prob_bound](double x) {
    double exp_x = exp(x);
    if (exp_x < prob_bound) return log(prob_bound);
    if (1 - exp_x < prob_bound) return log(1 - prob_bound);
    return x;
  };

  std::vector<double> clog_p(4);
  for (int i = 0; i < 4; ++i) {
    clog_p[i] = clampLogP(log_p[i]);
  }

  std::vector<double> exp_lp(4);
  for (int i = 0; i < 4; ++i) {
    exp_lp[i] = exp(clog_p[i]);
  }

  double lp0102;
  if ((1 - exp_lp[0] - exp_lp[1] < prob_bound) ||
      (1 - exp_lp[2] - exp_lp[3] < prob_bound)) {
    lp0102 = log(prob_bound);
  } else {
    double lp01 = log(std::abs(1 - exp_lp[0] - exp_lp[1]));
    double lp02 = log(std::abs(1 - exp_lp[2] - exp_lp[3]));
    lp0102 = lp01 + lp02;
  }

  std::vector<double> ret(4);
  if (effect1 == "RR") {
    ret[0] = alpha_tmp_1 - clog_p[0] - clog_p[2] + lp0102;
    ret[1] = beta_tmp_1[0] - clog_p[2] + clog_p[0];
  } else if (effect1 == "OR") {
    ret[0] = alpha_tmp_1 - clog_p[0] - clog_p[2] + lp0102;
    ret[1] = beta_tmp_1[0] - clog_p[2] + clog_p[0] +
      log(1 - exp_lp[2]) - log(1 - exp_lp[0]);
  } else if (effect1 == "SHR") {
    ret[0] = alpha_tmp_1 - clog_p[0] - clog_p[2] + lp0102;
    ret[1] = exp(beta_tmp_1[0]) - (log(1 - exp_lp[2]) / log(1 - exp_lp[0]));
  }

  if (effect2 == "RR") {
    ret[2] = alpha_tmp_2 - clog_p[1] - clog_p[3] + lp0102;
    ret[3] = beta_tmp_2[0] - clog_p[3] + clog_p[1];
  } else if (effect2 == "OR") {
    ret[2] = alpha_tmp_2 - clog_p[1] - clog_p[3] + lp0102;
    ret[3] = beta_tmp_2[0] - clog_p[3] + clog_p[1] +
      log(1 - exp_lp[3]) - log(1 - exp_lp[1]);
  } else if (effect2 == "SHR") {
    ret[2] = alpha_tmp_2 - clog_p[1] - clog_p[3] + lp0102;
    ret[3] = exp(beta_tmp_2[0]) - (log(1 - exp_lp[3]) / log(1 - exp_lp[1]));
  }

  double result = 0.0;
  for (int i = 0; i < 4; ++i) {
    result += ret[i] * ret[i];
  }
  return result;
}

// NLopt objective callback
double nlopt_obj(const std::vector<double> &x, std::vector<double> &grad, void *data) {
  CIFsData *d = reinterpret_cast<CIFsData*>(data);
  return CppObjectiveFunction(x, d->alpha_tmp_1, d->beta_tmp_1, d->alpha_tmp_2, d->beta_tmp_2, d->effect1, d->effect2, d->prob_bound);
}

// [[Rcpp::export]]
NumericVector calculatePotentialCIFs_cpp(
    NumericVector log_p0,
    double alpha_tmp_1,
    NumericVector beta_tmp_1,
    double alpha_tmp_2,
    NumericVector beta_tmp_2,
    std::string effect1,
    std::string effect2,
    double prob_bound,
    double xtol_rel = 1e-6,
    int maxeval = 100
) {
  nlopt::opt opt(nlopt::LD_LBFGS, 4);

  CIFsData data = { alpha_tmp_1,
                    Rcpp::as<std::vector<double>>(beta_tmp_1),
                    alpha_tmp_2,
                    Rcpp::as<std::vector<double>>(beta_tmp_2),
                    effect1, effect2,
                    prob_bound };

  opt.set_min_objective(nlopt_obj, &data);
  opt.set_xtol_rel(xtol_rel);
  opt.set_maxeval(maxeval);

  std::vector<double> x = Rcpp::as<std::vector<double>>(log_p0);
  double minf;
  nlopt::result res = opt.optimize(x, minf);

  return Rcpp::wrap(x);
}
