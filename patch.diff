diff --git a/R/functions-proportional.R b/R/functions-proportional.R
index 7f0f156b85a4f78abbc70eed630c1beef2fe3b73..bc4e67cdf7cc41c4ee1dc52845796e1ef74b710c 100644
--- a/R/functions-proportional.R
+++ b/R/functions-proportional.R
@@ -1,36 +1,37 @@
 solveEstimatingEquation <- function(
     nuisance.model,
     exposure,
     strata,
     normalized_data,
     outcome.type,
     estimand,
     optim.method,
     out_normalizeCovariate,
     prob.bound,
-    alpha_beta_0
+    alpha_beta_0,
+    L1.penalty = FALSE
 ) {
   if (outcome.type == "COMPETING-RISK" | outcome.type == "SURVIVAL") {
     ip.weight <- calculateIPCW(nuisance.model, normalized_data, estimand$code.censoring, strata, estimand$time.point)
   } else if (outcome.type == "BINOMIAL") {
     ip.weight <- rep(1,nrow(normalized_data))
   } else if (outcome.type == "PROPORTIONAL" | outcome.type == "POLY-PROPORTIONAL") {
     ip.weight.matrix <- calculateIPCWMatrix(nuisance.model, normalized_data, estimand$code.censoring, strata, estimand, out_normalizeCovariate)
   }
 
   # ---- 目的関数/推定式（polyreg() 準拠） ---------------------------------------
   makeObjectiveFunction <- function() {
     out_ipcw <- list()
     initial.CIFs <- NULL
 
     call_and_capture <- function(fun, ...) {
       out_ipcw <<- do.call(fun, list(...))
       out_ipcw$ret
     }
 
     estimating_equation_i <- function(p) call_and_capture(
       estimating_equation_ipcw,
       formula = nuisance.model, data = normalized_data, exposure = exposure,
       ip.weight = ip.weight, alpha_beta = p, estimand = estimand,
       optim.method = NULL, prob.bound = prob.bound,
       initial.CIFs = initial.CIFs
diff --git a/R/functions-proportional.R b/R/functions-proportional.R
index 7f0f156b85a4f78abbc70eed630c1beef2fe3b73..bc4e67cdf7cc41c4ee1dc52845796e1ef74b710c 100644
--- a/R/functions-proportional.R
+++ b/R/functions-proportional.R
@@ -117,73 +118,76 @@ solveEstimatingEquation <- function(
       stop("Unknown outcome.type: ", outcome.type)
     }
   }
 
   choose_nleqslv_method <- function(nleqslv.method) {
     if (nleqslv.method %in% c("nleqslv", "Broyden")) {
       "Broyden"
     } else if (nleqslv.method == "Newton") {
       "Newton"
     } else {
       stop("Unsupported nleqslv.method without optim(): ", nleqslv.method)
     }
   }
 
   get_obj_value <- switch(outcome.type,
                           "COMPETING-RISK"   = function(p) drop(crossprod(obj$estimating_equation_i(p))),
                           "SURVIVAL"         = function(p) drop(crossprod(obj$estimating_equation_s(p))),
                           "BINOMIAL"         = function(p) drop(crossprod(obj$estimating_equation_s(p))),
                           "PROPORTIONAL"     = function(p) drop(crossprod(obj$estimating_equation_p(p))),
                           "POLY-PROPORTIONAL"= function(p) drop(crossprod(obj$estimating_equation_pp(p))),
                           stop("Unknown outcome.type: ", outcome.type)
   )
 
   # ---- ループ（polyreg() と同じ構造） ------------------------------------------
   obj <- makeObjectiveFunction()
+  l1_spec <- resolve_l1_penalty(L1.penalty, nrow(normalized_data), estimand$index.vector[1])
+  l1_indices <- if (l1_spec$enabled) select_l1_indices(outcome.type, estimand$index.vector) else integer(0)
+  apply_l1_update <- function(params) apply_proximal_l1(params, l1_spec$lambda, l1_indices)
   estimating_fun <- choose_estimating_equation(outcome.type, obj)
   nleqslv_method <- choose_nleqslv_method(optim.method$nleqslv.method)
 
   iteration <- 0L
   max.absolute.difference <- Inf
   out_nleqslv <- NULL
-  current_params <- alpha_beta_0
+  current_params <- apply_l1_update(alpha_beta_0)
   current_obj_value <- numeric(0)
   trace_df  <- NULL
 
   computation.time0 <- proc.time()
 
   while ((iteration < optim.method$optim.parameter4) & (max.absolute.difference > optim.method$optim.parameter1)) {
     iteration <- iteration + 1L
     prev_params <- current_params
 
     out_nleqslv <- nleqslv(
       prev_params,
       estimating_fun,
       method  = optim.method$nleqslv_method,
       control = list(maxit = optim.method$optim.parameter5, allowSingular = FALSE)
     )
-    new_params <- out_nleqslv$x
+    new_params <- apply_l1_update(out_nleqslv$x)
 
     # 目的関数値と内部状態の更新
     current_obj_value <- get_obj_value(new_params)
     obj$setInitialCIFs(obj$getResults()$potential.CIFs)
 
     # 収束判定（既存の assessConvergence() を利用する前提）
     ac <- assessConvergence(
       new_params, prev_params, current_obj_value,
       optim.method$optim.parameter1, optim.method$optim.parameter2, optim.method$optim.parameter3
     )
     current_params <- new_params
     max.absolute.difference <- ac$max.absolute.difference
     if (ac$converged) break
   }
   return(current_params)
 }
 
 solveEstimatingEquationP <- function(
     nuisance.model,
     exposure,
     strata,
     normalized_data,
     estimand,
     out_normalizeCovariate,
     optim.method,
