diff --git a/R/functions-IPCW-estimating-equations.r b/R/functions-IPCW-estimating-equations.r
index 61b835ab31792827da68a87b570fd2c8faf1620a..2350c4441305d4010156941dacb9293478a7acf7 100644
--- a/R/functions-IPCW-estimating-equations.r
+++ b/R/functions-IPCW-estimating-equations.r
@@ -154,92 +154,123 @@ calculateCov <- function(objget_results, estimand, prob.bound)
       AB2[i_score, i_para] <- AB2[i_score, i_para] + integral2[n]
     }
   }
 
   out_calculateD <- calculateD(potential.CIFs, x_a, x_l, estimand, prob.bound)
   hesse_d11 <- crossprod(x_la, w11 * out_calculateD$d_11) / n
   hesse_d12 <- crossprod(x_la, w12 * out_calculateD$d_12) / n
   hesse_d22 <- crossprod(x_la, w22 * out_calculateD$d_22) / n
 
   hesse_d1 <- cbind(hesse_d11, hesse_d12)
   hesse_d2 <- cbind(hesse_d12, hesse_d22)
   hesse <- rbind(hesse_d1, hesse_d2)
 
   total_score <- cbind(AB1, AB2)
   influence.function <- t(solve(hesse, t(total_score)))
   cov_estimated <- crossprod(influence.function) / n^2
   if (ncol(influence.function)==4) {
     colnames(influence.function) <- c("intercept", "exposure", "intercept", "exposure")
   } else if (ncol(influence.function)>4) {
     colnames(influence.function) <- c("intercept", paste("covariate", 1:(ncol(influence.function)/2 - 2), sep = ""), "exposure",
                                       "intercept", paste("covariate", 1:(ncol(influence.function)/2 - 2), sep = ""), "exposure")
   }
   return(list(cov_estimated = cov_estimated, score.function = total_score, influence.function = influence.function))
 }
 
-calculateD <- function(potential.CIFs, x_a, x_l, estimand, prob.bound) { #•ª—Þ”˜˜I–¢‘Î‰ž
-  CIF1 <- ifelse(potential.CIFs[, 1] == 0, prob.bound, ifelse(potential.CIFs[, 1] == 1, 1 - prob.bound, potential.CIFs[, 1]))
-  CIF2 <- ifelse(potential.CIFs[, 2] == 0, prob.bound, ifelse(potential.CIFs[, 2] == 1, 1 - prob.bound, potential.CIFs[, 2]))
-  CIF3 <- ifelse(potential.CIFs[, 3] == 0, prob.bound, ifelse(potential.CIFs[, 3] == 1, 1 - prob.bound, potential.CIFs[, 3]))
-  CIF4 <- ifelse(potential.CIFs[, 4] == 0, prob.bound, ifelse(potential.CIFs[, 4] == 1, 1 - prob.bound, potential.CIFs[, 4]))
+calculateD <- function(potential.CIFs, x_a, x_l, estimand, prob.bound) {
+  x_a <- as.matrix(x_a)
+  n <- nrow(x_l)
+  if (nrow(x_a) != n) stop("Row dimension of x_a and x_l must match.")
+  K <- if (!is.null(estimand$exposure.levels)) estimand$exposure.levels else (ncol(x_a) + 1L)
+  if (ncol(potential.CIFs) != 2 * K) stop("Column dimension of potential.CIFs is not 2 * K.")
+
+  seq_n <- seq_len(n)
+  idx <- max.col(cbind(0, x_a), ties.method = "first")
+
+  clamp_prob <- function(x) {
+    x <- pmax(x, prob.bound)
+    x <- pmin(x, 1 - prob.bound)
+    return(x)
+  }
+
+  CIF1_mat <- clamp_prob(potential.CIFs[, seq_len(K), drop = FALSE])
+  CIF2_mat <- clamp_prob(potential.CIFs[, K + seq_len(K), drop = FALSE])
+  survival_mat <- pmax(1 - CIF1_mat - CIF2_mat, prob.bound)
+
+  CIF1_sel <- CIF1_mat[cbind(seq_n, idx)]
+  CIF2_sel <- CIF2_mat[cbind(seq_n, idx)]
+  survival_sel <- survival_mat[cbind(seq_n, idx)]
 
-  calculateA <- function(effect_measure, exposed.CIFs, unexposed.CIFs, a) {
+  calculateA <- function(effect_measure, CIFs_selected) {
+    CIFs_selected <- clamp_prob(CIFs_selected)
     if (effect_measure == "RR") {
-      return(a * (1 / exposed.CIFs) + (1 - a) * (1 / unexposed.CIFs))
+      return(1 / CIFs_selected)
     } else if (effect_measure == "OR") {
-      return(a * (1 / exposed.CIFs + 1 / (1 - exposed.CIFs)) + (1 - a) * (1 / unexposed.CIFs + 1 / (1 - unexposed.CIFs)))
+      denom <- clamp_prob(1 - CIFs_selected)
+      return(1 / CIFs_selected + 1 / denom)
     } else if (effect_measure == "SHR") {
-      tmp1_exposed <- -1 / (1 - exposed.CIFs)
-      tmp1_unexposed <- -1 / (1 - unexposed.CIFs)
-      tmp2_exposed <- log(1 - exposed.CIFs)
-      tmp2_unexposed <- log(1 - unexposed.CIFs)
-      return(a * (tmp1_exposed / tmp2_exposed) + (1 - a) * (tmp1_unexposed / tmp2_unexposed))
+      denom <- clamp_prob(1 - CIFs_selected)
+      tmp1 <- -1 / denom
+      tmp2 <- log(denom)
+      return(tmp1 / tmp2)
     } else {
       stop("Invalid effect_measure. Must be RR, OR or SHR.")
     }
   }
 
-  a <- as.vector(x_a)
-  a11 <- a12 <- a22 <- NULL
-  a11 <- calculateA(estimand$effect.measure1, CIF2, CIF1, a)
-  a22 <- calculateA(estimand$effect.measure2, CIF4, CIF3, a)
-#  a11 <- calculateA(estimand$effect.measure1, CIF3, CIF1, a)
-#  a22 <- calculateA(estimand$effect.measure2, CIF4, CIF2, a)
-  a12 <- matrix(0, nrow = length(x_a), ncol = 1)
-
-  d_ey_d_beta_11 <- a22 / (a11 * a22 - a12 * a12)
-  d_ey_d_beta_12 <- -a12 / (a11 * a22 - a12 * a12)
-  d_ey_d_beta_22 <- a11 / (a11 * a22 - a12 * a12)
-  c12 <- a * (1 / (1 - CIF2 - CIF4)) + (1 - a) * (1 / (1 - CIF1 - CIF3))
+  a11 <- calculateA(estimand$effect.measure1, CIF1_sel)
+  a22 <- calculateA(estimand$effect.measure2, CIF2_sel)
+  a12 <- rep(0, length.out = n)
+
+  denom_beta <- a11 * a22 - a12 * a12
+  d_ey_d_beta_11 <- a22 / denom_beta
+  d_ey_d_beta_12 <- -a12 / denom_beta
+  d_ey_d_beta_22 <- a11 / denom_beta
+
+  c12 <- 1 / survival_sel
   c11 <- a11 + c12
   c22 <- a22 + c12
-  d_ey_d_alpha_11 <- c22 / (c11 * c22 - c12 * c12)
-  d_ey_d_alpha_12 <- -c12 / (c11 * c22 - c12 * c12)
-  d_ey_d_alpha_22 <- c11 / (c11 * c22 - c12 * c12)
-  d_11 <- cbind((d_ey_d_alpha_11 * x_l), (d_ey_d_beta_11 * a))
-  d_12 <- cbind((d_ey_d_alpha_12 * x_l), (d_ey_d_beta_12 * a))
-  d_22 <- cbind((d_ey_d_alpha_22 * x_l), (d_ey_d_beta_22 * a))
+
+  denom_alpha <- c11 * c22 - c12 * c12
+  d_ey_d_alpha_11 <- c22 / denom_alpha
+  d_ey_d_alpha_12 <- -c12 / denom_alpha
+  d_ey_d_alpha_22 <- c11 / denom_alpha
+
+  scale_matrix <- function(mat, vec) {
+    if (is.null(mat) || ncol(mat) == 0) {
+      return(NULL)
+    }
+    sweep(mat, 1, vec, `*`)
+  }
+
+  beta_11 <- scale_matrix(x_a, d_ey_d_beta_11)
+  beta_12 <- scale_matrix(x_a, d_ey_d_beta_12)
+  beta_22 <- scale_matrix(x_a, d_ey_d_beta_22)
+
+  d_11 <- cbind(sweep(x_l, 1, d_ey_d_alpha_11, `*`), beta_11)
+  d_12 <- cbind(sweep(x_l, 1, d_ey_d_alpha_12, `*`), beta_12)
+  d_22 <- cbind(sweep(x_l, 1, d_ey_d_alpha_22, `*`), beta_22)
   return(list(d_11 = d_11, d_12 = d_12, d_22 = d_22))
 }
 
 estimating_equation_survival <- function(
     formula,
     data,
     exposure,
     ip.weight,
     alpha_beta,
     estimand,
     optim.method,
     prob.bound,
     initial.CIFs = NULL
 ) {
   cl <- match.call()
   mf <- match.call(expand.dots = TRUE)[1:3]
   special <- c("strata", "cluster", "offset")
   Terms <- terms(formula, special, data = data)
   mf$formula <- Terms
   mf[[1]] <- as.name("model.frame")
   mf <- eval(mf, parent.frame())
   Y <- model.extract(mf, "response")
 
   if (!inherits(Y, c("Event", "Surv"))) {
     t <- rep(0, length(Y))
diff --git a/R/functions-IPCW-estimating-equations.r b/R/functions-IPCW-estimating-equations.r
index 61b835ab31792827da68a87b570fd2c8faf1620a..2350c4441305d4010156941dacb9293478a7acf7 100644
--- a/R/functions-IPCW-estimating-equations.r
+++ b/R/functions-IPCW-estimating-equations.r
@@ -332,76 +363,91 @@ calculateCovSurvival <- function(objget_results, estimand, prob.bound)
     tmp0 <- x_la[, i_para]
     use <- (t <= estimand$time.point)
     tmp1 <- colSums((use * tmp0) * (outer(t, t, ">=") * wy_1))
     tmp1 <- tmp1 / survival_km / n
     integrand1 <- tmp1 * censoring_mkm
     for (i_score in 1:n) {
       integral1 <- cumsum(integrand1[i_score, ])
       AB1[i_score, i_para] <- AB1[i_score, i_para] + integral1[n]
     }
   }
   out_calculateDSurvival <- calculateDSurvival(potential.CIFs, x_a, x_l, estimand, prob.bound)
   hesse <- crossprod(x_la, w11 * out_calculateDSurvival) / n
 
   total_score <- AB1
   influence.function <- t(solve(hesse, t(total_score)))
   cov_estimated <- crossprod(influence.function) / n^2
   if (ncol(influence.function)==2) {
     colnames(influence.function) <- c("intercept", "exposure")
   } else if (ncol(influence.function)>2) {
     colnames(influence.function) <- c("intercept", paste("covariate", 1:(ncol(influence.function) - 2), sep = ""), "exposure")
   }
   return(list(cov_estimated = cov_estimated, score.function = total_score, influence.function = influence.function))
 }
 
 calculateDSurvival <- function(potential.CIFs, x_a, x_l, estimand, prob.bound) {
-  CIF1 <- ifelse(potential.CIFs[, 1] == 0, prob.bound, ifelse(potential.CIFs[, 1] == 1, 1 - prob.bound, potential.CIFs[, 1]))
-  CIF2 <- ifelse(potential.CIFs[, 2] == 0, prob.bound, ifelse(potential.CIFs[, 2] == 1, 1 - prob.bound, potential.CIFs[, 2]))
+  x_a <- as.matrix(x_a)
+  n <- nrow(x_l)
+  if (nrow(x_a) != n) stop("Row dimension of x_a and x_l must match.")
+  K <- if (!is.null(estimand$exposure.levels)) estimand$exposure.levels else (ncol(x_a) + 1L)
+  if (ncol(potential.CIFs) < K) stop("Column dimension of potential.CIFs is insufficient for the number of exposure levels.")
+
+  seq_n <- seq_len(n)
+  idx <- max.col(cbind(0, x_a), ties.method = "first")
+
+  clamp_prob <- function(x) {
+    x <- pmax(x, prob.bound)
+    x <- pmin(x, 1 - prob.bound)
+    return(x)
+  }
 
-  calculateA <- function(effect_measure, exposed.CIFs, unexposed.CIFs, a) {
+  CIF_mat <- clamp_prob(potential.CIFs[, seq_len(K), drop = FALSE])
+  CIF_sel <- CIF_mat[cbind(seq_n, idx)]
+
+  calculateA <- function(effect_measure, CIFs_selected) {
+    CIFs_selected <- clamp_prob(CIFs_selected)
     if (effect_measure == "RR") {
-      return(a * (1 / exposed.CIFs) + (1 - a) * (1 / unexposed.CIFs))
+      return(1 / CIFs_selected)
     } else if (effect_measure == "OR") {
-      return(a * (1 / exposed.CIFs + 1 / (1 - exposed.CIFs)) + (1 - a) * (1 / unexposed.CIFs + 1 / (1 - unexposed.CIFs)))
+      denom <- clamp_prob(1 - CIFs_selected)
+      return(1 / CIFs_selected + 1 / denom)
     } else if (effect_measure == "SHR") {
-      tmp1_exposed <- -1 / (1 - exposed.CIFs)
-      tmp1_unexposed <- -1 / (1 - unexposed.CIFs)
-      tmp2_exposed <- log(1 - exposed.CIFs)
-      tmp2_unexposed <- log(1 - unexposed.CIFs)
-      return(a * (tmp1_exposed / tmp2_exposed) + (1 - a) * (tmp1_unexposed / tmp2_unexposed))
+      denom <- clamp_prob(1 - CIFs_selected)
+      tmp1 <- -1 / denom
+      tmp2 <- log(denom)
+      return(tmp1 / tmp2)
     } else {
       stop("Invalid effect_measure. Must be RR, OR or SHR.")
     }
   }
 
-  a <- as.vector(x_a)
-  a11 <-NULL
-  a11 <- calculateA(estimand$effect.measure1, CIF2, CIF1, a)
-
+  a11 <- calculateA(estimand$effect.measure1, CIF_sel)
   d_ey_d_beta_11 <- 1 / a11
   d_ey_d_alpha_11 <- 1 / a11
-  d_11 <- cbind((d_ey_d_alpha_11 * x_l), (d_ey_d_beta_11 * x_a))
+
+  beta_11 <- if (ncol(x_a) == 0) NULL else sweep(x_a, 1, d_ey_d_beta_11, `*`)
+  d_11 <- cbind(sweep(x_l, 1, d_ey_d_alpha_11, `*`), beta_11)
   return(d_11)
 }
 
 estimating_equation_proportional <- function(
     formula,
     data,
     exposure,
     ip.weight.matrix,
     alpha_beta,
     estimand,
     optim.method,
     prob.bound,
     initial.CIFs = NULL
 ) {
   cl <- match.call()
   mf <- match.call(expand.dots = TRUE)[1:3]
   special <- c("strata", "cluster", "offset")
   Terms <- terms(formula, special, data = data)
   mf$formula <- Terms
   mf[[1]] <- as.name("model.frame")
   mf <- eval(mf, parent.frame())
   Y <- model.extract(mf, "response")
   if (!inherits(Y, c("Event", "Surv"))) {
     t <- rep(0, length(Y))
     epsilon <- Y
